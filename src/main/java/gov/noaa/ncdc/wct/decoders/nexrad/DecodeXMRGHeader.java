/**
 * NOAA's National Climatic Data Center
 * NOAA/NESDIS/NCDC
 * 151 Patton Ave, Asheville, NC  28801
 * 
 * THIS SOFTWARE AND ITS DOCUMENTATION ARE CONSIDERED TO BE IN THE 
 * PUBLIC DOMAIN AND THUS ARE AVAILABLE FOR UNRESTRICTED PUBLIC USE.  
 * THEY ARE FURNISHED "AS IS." THE AUTHORS, THE UNITED STATES GOVERNMENT, ITS
 * INSTRUMENTALITIES, OFFICERS, EMPLOYEES, AND AGENTS MAKE NO WARRANTY,
 * EXPRESS OR IMPLIED, AS TO THE USEFULNESS OF THE SOFTWARE AND
 * DOCUMENTATION FOR ANY PURPOSE. THEY ASSUME NO RESPONSIBILITY (1)
 * FOR THE USE OF THE SOFTWARE AND DOCUMENTATION; OR (2) TO PROVIDE
 * TECHNICAL SUPPORT TO USERS.
 */

package gov.noaa.ncdc.wct.decoders.nexrad;

import gov.noaa.ncdc.wct.decoders.MaxGeographicExtent;

import java.net.URL;
import java.text.DecimalFormat;
import java.util.Calendar;

import com.vividsolutions.jts.geom.Coordinate;

/**
 *  Decodes basic header information from NWS XMRG Files <br><br>
 *
 *  "Hourly precip estimates on an HRAP grid generated by MPE and
 *   Stage3 are written in xmrg format.  The xmrg files used as 
 *   input to the NWSRFS Operational Forecast System NEXRAD Mean 
 *   Areal Precipitation (MAPX) Preprocessor." -- From xmrg.wpd documentation. 
 * 
 *
 * @author     steve.ansari
 * @created    Feb 15, 2005
 */
public class DecodeXMRGHeader implements NexradHeader {

   public String[] dataThresholdString = new String[16];
   
   private DecimalFormat fmt02 = new DecimalFormat("00");
   
   private ucar.unidata.io.RandomAccessFile f;
   private URL nexrad_url;
   private Level2Format record = null;
   private RadarHashtables nxhash = null;
   
   private double lat, lon, alt;
   private char opmode = ' ';
   private short vcp;
   private int pcode = NexradHeader.XMRG;
   
   private int llHrapX, llHrapY, numHrapX, numHrapY;
   private int maxValue;
   private float versionNum;
   private String validDateTime, processFlag, saveDateTime, userID, opSys;
   private long gendate;
   private Calendar genCalendar = Calendar.getInstance();
   private int year, month, day, hour, minute, seconds;
   
   public DecodeXMRGHeader() {
      // Initiate the Nexrad Hashtable -- load from /shapefiles/wsr.dbf
      nxhash = RadarHashtables.getSharedInstance();
   }
   
   
   public void decodeHeader(URL url) {

      nexrad_url = url;
      
      // Initiate binary buffered read
      try {
         if (url.getProtocol().equals("file")) {
            f = new ucar.unidata.io.RandomAccessFile(url.getFile().replaceAll("%20", " "),"r");
         }
         else {
            f = new ucar.unidata.io.http.HTTPRandomAccessFile(url.toString());
         }

         f.order(ucar.unidata.io.RandomAccessFile.LITTLE_ENDIAN);         
         
         
         // Fortran unformatted record begin - 4-byte int with number of bytes (16)
         int numWords0 = f.readInt();  
         f.seek(0);         


         // see if we need to change byteorder
         if (numWords0 < 0 || numWords0 > 100) {
            f.order(ucar.unidata.io.RandomAccessFile.BIG_ENDIAN);
            System.out.println("BIG_ENDIAN BYTE ORDER DETECTED FOR THIS XMRG FILE");
         }
         else {
            System.out.println("LITTLE_ENDIAN BYTE ORDER DETECTED FOR THIS XMRG FILE");
         }
         
         
         
         
      } catch (Exception e) {
         e.printStackTrace();
         System.out.println("ERROR WITH URL: "+url);
         return;
      }


      
      try {
         // Fortran unformatted record begin - 4-byte int with number of bytes (16)
         int numWords0 = f.readInt();  
         
         llHrapX = f.readInt();
         llHrapY = f.readInt();
         numHrapX = f.readInt();
         numHrapY = f.readInt();
         
         // Fortran unformatted record end - 4-byte int with number of bytes (16)
         int numWords1 = f.readInt(); 
         
         // Fortran unformatted record begin - 4-byte int with number of bytes (66)
         int numWords2= f.readInt(); 
         
        
         byte[] bytes = new byte[2];
         f.read(bytes);
         opSys = new String(bytes);
         
         bytes = new byte[8];
         f.read(bytes);         
         userID = new String(bytes);
         
         bytes = new byte[20];
         f.read(bytes);         
         saveDateTime = new String(bytes);

         bytes = new byte[8];
         f.read(bytes);         
         processFlag = new String(bytes);

         bytes = new byte[20];
         f.read(bytes);         
         validDateTime = new String(bytes);
         
         maxValue = f.readInt();
         versionNum = f.readFloat();
         //versionNum = Swap.swapFloat(f.readFloat());  // OLD WAY - SWAPS BYTES
         
         // Fortran unformatted record end - 4-byte int with number of bytes (66)
         int numWords3= f.readInt(); 
         
         
         // Fortran unformatted record begin - 4-byte int with number of bytes (numHrapX * 2)
         //int numWords4= f.readInt(); 

         
         // 012345678901234567890
         // 2004-09-19 00:00:00
         year = Integer.parseInt(validDateTime.substring(0, 4));
         month = Integer.parseInt(validDateTime.substring(5, 7));
         day = Integer.parseInt(validDateTime.substring(8, 10));
         hour = Integer.parseInt(validDateTime.substring(11, 13));
         minute = Integer.parseInt(validDateTime.substring(14, 16));
         seconds = Integer.parseInt(validDateTime.substring(17, 19));
         
         genCalendar.set(year, month, day, hour, minute, (int)seconds);
         gendate = genCalendar.getTimeInMillis();


         
         lat = NexradHeader.NO_SITE_DEFINED;
         lon = NexradHeader.NO_SITE_DEFINED;
         alt = NexradHeader.NO_SITE_DEFINED;
/*         
System.out.println("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM");         
System.out.println("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM");
System.out.println("");
System.out.println("NUM WORDS0: "+numWords0);
System.out.println(" LL HRAP X: "+llHrapX);
System.out.println(" LL HRAP Y: "+llHrapY);
System.out.println("NUM HRAP X: "+numHrapX);
System.out.println("NUM HRAP Y: "+numHrapY);
System.out.println("NUM WORDS1: "+numWords1);
System.out.println("NUM WORDS2: "+numWords2);
System.out.println("    OP SYS: "+opSys);
System.out.println("   USER ID: "+userID);
System.out.println(" SAVE DATE: "+saveDateTime);
System.out.println(" PROC FLAG: "+processFlag);
System.out.println("VALID DATE: "+validDateTime);
System.out.println(" MAX VALUE: "+maxValue);
System.out.println("   VERSION: "+versionNum);
System.out.println("NUM WORDS3: "+numWords3);
//System.out.println("NUMWORDSY0: "+numWords4);
System.out.println("");
System.out.println("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM");         
System.out.println("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM");         
*/


      } catch (Exception e) {
         e.printStackTrace();
         return;
      }
     
      
   }

   
   public URL getDataURL() {
      return nexrad_url;
   }
   
   /**
    * Gets general product type defined in NexradHeader (LEVEL2, L3RADIAL, L3RASTER, etc.)
    */
   public int getProductType() {
      return NexradHeader.XMRG;
   }
   
   public ucar.unidata.io.RandomAccessFile getRandomAccessFile() {
      return f;
   }



   /**
	 * Returns lower left HRAP X coordinate (llHrapX).
	 */
	public int getLlHrapX()	{
		return llHrapX;
	}
 	/**
	 * Returns lower left HRAP Y coordinate (llHrapY).
	 */
	public int getLlHrapY()	{
		return llHrapY;
	}
   /**
    * Returns number of X grid cells (numHrapX).
	 */
	public int getNumHrapX() {
		return numHrapX;
	}
	/**
	 * Returns number of Y grid cells (numHrapY).
	 */
   public int getNumHrapY() {
		return numHrapY;
	}
	/**
	 * Returns the maxValue.
	 */
   public int getMaxValue() {
		return maxValue;
	}
	/**
	 * Returns the version number.
	 */
   public float getVersion() {
		return versionNum;
	}
	/**
	 * Returns the valid Date and Time in ccyy-mm-dd hh:mm:ss (Z time) format.
	 */
   public String getValidDateTime() {
		return validDateTime;
	}
	/**
	 * Returns the saved Date and Time in ccyy-mm-dd hh:mm:ss (Z time) format.
	 */
   public String getSaveDateTime() {
		return saveDateTime;
	}
   
	/**
	 * Returns the process flag. <br>
    * <pre>
    * The process flag is defined as follows:
    *
    * XXyHH
    *
    * where XX = process code
    *   y = A (automatic) or M (manual)
    *   HH = duration in hours
    *
    * Examples are:
    *  auto_stageiii    - S3A01
    *  manual stageiii  - S3M01
    *  mpe_fieldgen     - MPA01 
    *  mpe_gui          - MPM01
    *
	 */
   public String getProcessFlag() {
		return processFlag;
	}
	/**
	 * Returns the user id of the person who created the product.
	 */
   public String getUserID() {
		return userID;
	}
	/**
	 * Returns a 2 character description of the operating system. 
    * --- 'HP' or 'LX' ---
	 */
   public String getOpSys() {
		return opSys;
	}






















   /** Implementation of NexradHeader interface.  Not applicable for XMRG data.
    *
    * @return    null
    */
   public String getICAO() {
      System.err.println("getICAO method not supported for DecodeXMRGHeader  "+ getDataURL());
      return null;
   }
   

   
   

   /**
    * Returns NEXRAD Site Latitude
    *
    * @return    The lat value
    */
   public double getLat() {
      return lat;
   }


   /**
    * Returns NEXRAD Site Longitude
    *
    * @return    The lon value
    */
   public double getLon() {
      return lon;
   }


   /**
    * Returns NEXRAD Site Altitude
    *
    * @return    The alt value in feet
    */
   public double getAlt() {
      return alt;
   }
   
   
   

   
   /**
    * Returns Date of product creation in milliseconds from 1970-1-1 GMT
    *
    * @return    The date value
    */
   public long getMilliseconds() {
      return gendate;
   }
   
      
   
   /**
    * Returns Date of product creation as yyyymmdd int
    *
    * @return    The date value
    */
   public int getDate() {
      return Integer.parseInt(validDateTime.substring(0, 4) + 
         validDateTime.substring(5, 7) + validDateTime.substring(8, 10));
   }


   /**
    * Returns UTC Hour of product creation
    *
    * @return    The hour value
    */
   public short getHour() {
      // 012345678901234567890
      // 2004-09-19 00:00:00
      return (short)hour;
   }

   /**
    * Returns UTC Hour of product creation
    *
    * @return    The hour value in 2 digit string
    */
   public String getHourString() {
      return validDateTime.substring(11, 13);
   }


   /**
    * Returns UTC Minute of product creation
    *
    * @return    The minute value
    */
   public short getMinute() {
      return (short)minute;
   }

   /**
    * Returns UTC Minute of product creation
    *
    * @return    The minute value in 2 digit string
    */
   public String getMinuteString() {
      return validDateTime.substring(14, 16);
   }
   

   /**
    * Returns UTC Second of product creation
    *
    * @return    The second value
    */
   public short getSecond() {
      return (short)seconds;
   }

   /**
    * Returns UTC Second of product creation
    *
    * @return    The second value in 2 digit string
    */
   public String getSecondString() {
      return validDateTime.substring(17, 19);
   }
   
   
   public String getScanTimeString() {
      return (fmt02.format(hour)+":"+fmt02.format(minute)+":"+fmt02.format(seconds));
   }
   
   public void setScanTime(int milliseconds) {
      this.gendate = milliseconds;
   }
   
   
   
   /**
    * Returns NexradHeader.LEVEL2 to indicate Level-2 Product
    *
    * @return    NexradHeader.LEVEL2
    */
   public short getProductCode() {
      return (short)pcode;
   }

   /**
    * Allows decoder to set product code based on Level-2 Moment 
    * variable set in gov.noaa.ncdc.iras.Level2Format. <br>
    *
    * For Level-3 products the product code is decoded in the header.
    *
    */
   protected void setProductCode(int level2RecordMoment) {
      if (level2RecordMoment == Level2Format.REFLECTIVITY) {
         pcode = NexradHeader.LEVEL2_REFLECTIVITY;
      }
      else if (level2RecordMoment == Level2Format.VELOCITY) {
         pcode = NexradHeader.LEVEL2_VELOCITY;
      }
      else {
         pcode = NexradHeader.LEVEL2_SPECTRUMWIDTH;
      }
   }

   
   
   
   /**
    * Returns operational mode
    *
    * @return  Empty character because operational mode is not provided in level-2 data
    */
   public char getOpMode() {
      return opmode;
   }
   
   
   
   /**
    * Returns volume coverage pattern (vcp)
    *
    * @return    The vcp value
    */
    public short getVCP() {
       return vcp;
    }
   
   /**
    * Sets volume coverage pattern (vcp)
    *
    */
    protected void setVCP(short vcp) {
       this.vcp = vcp;
    }
    
    
   
   /**
    * Returns Data Threshold Values
    *
    * @param  index  Description of the Parameter
    * @return        The dataThresholdValue value
    */
   public String getDataThresholdString(int index) {
      try {
         return dataThresholdString[index];
      } catch (Exception e) {
         e.printStackTrace();
         return "N/A";
      }
   }
   
   
   /**
    * Sets Data Threshold Values --- needed because threshold values
    * are unknown until a moment has been selected and decoded.
    *
    * @param  threshold  Threshold string value
    * @param  index  index of threshold string
    */
   protected void setDataThresholdString(String threshold, int index) {
      try {
         dataThresholdString[index] = threshold;
      } catch (Exception e) {
         e.printStackTrace();
         dataThresholdString[index] = "N/A";
      }
   }

   
   /**
    * Sets Data Threshold Values --- needed because threshold values
    * are unknown until a moment has been selected and decoded.
    *
    * @param  threshold  Array of Threshold strings 
    * @param  index  index of threshold string
    */
   protected void setDataThresholdStringArray(String[] dataThresholdString) {
      this.dataThresholdString = dataThresholdString;
   }
   
   
   /**
    *  Gets the numberOfLevels attribute of the DecodeL3Header object.  
    *  Will return UNKNOWN if using DPA since actual DPA values (inches or mm)
    *  are returned.
    *
    * @return    The numberOfLevels value
    */
   public int getNumberOfLevels(boolean classify) {
      return NexradColorFactory.getColors(pcode, classify).length;
   }

   
   /**
    *  Description of the Method
    *
    * @param  jdate  Description of the Parameter
    * @return        Description of the Return Value
    */
   private int convertJulianDate(int jdate) {

      int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
      int year;
      int month = 0;
      int ndays;
      int day = 0;
      int total;
      int len;
      int i;
      boolean leap_year;

      total = 0;
      for (year = 1970; year < 2098; year++) {
         leap_year = false;
         if (year % 4 == 0) {
            leap_year = true;
         }

         for (month = 0; month < 12; month++) {
            total = total + days[month];
            if (month == 1 && leap_year) {
               total++;
            }
            if (total >= jdate) {
               ndays = days[month];
               if (month == 1 && leap_year) {
                  ndays++;
               }
               day = ndays - (total - jdate);
               month = month + 1;
               return (year * 10000 + month * 100 + day);
            }
         }
      }
      return -999;
   }
   // END convertJulianDate


   public RadarHashtables getNexradHashtables() {
      return nxhash;
   }

   
   /**
    * Returns Rectangle.Double Bounds for the NEXRAD Site calculated during decode. (unique to product)
    * Could be 248, 124 or 32 nmi.
    *
    * @return    The bounds value
    */
   public java.awt.geom.Rectangle2D.Double getNexradBounds() {
      return (MaxGeographicExtent.getNexradExtent(this));
   }
   
   
   

   /**
    *  Gets lon, lat location of Radar site as Coordinate 
    *
    * @return                 The radar location as a Coordinate object
    */
   public Coordinate getRadarCoordinate() {
      return new Coordinate(lon, lat);
   }


   
   
   
   public void closeFile() {
      try {
         f.close();
         f = null;
      } catch (Exception e) {
         e.printStackTrace();
      }
   }
   
   
   public void finalize() {
      try {
         System.out.println("CALLING DecodeXMRGHeader FINALIZE");
         f.close();
      } catch (Exception e) {
         e.printStackTrace();
      }
   }
   
   




   
   
   public static void main(String[] args) {
      try {
         DecodeXMRGHeader xmrgHeader = new DecodeXMRGHeader();
         xmrgHeader.decodeHeader(new java.io.File("D:\\Nexrad_Viewer_Test\\XMRG\\serfc\\xmrg_09192004_00z_SE").toURL());
      } catch (Exception e) {
         e.printStackTrace();
      }
   }
   
   

   
   
   
   
}

